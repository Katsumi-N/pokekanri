// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: collection.sql

package dbgen

import (
	"context"
)

const collectionFindByUserId = `-- name: CollectionFindByUserId :many
SELECT 
    i.id,
    COALESCE(p.id, t.id, e.id) AS card_id,
    i.card_type_id AS card_type_id,
    COALESCE(p.name, t.name, e.name) AS name,
    COALESCE(p.image_url, t.image_url) AS image_url,
    i.quantity
FROM inventories i
LEFT JOIN pokemons p ON i.card_id = p.id AND i.card_type_id = 1
LEFT JOIN trainers t ON i.card_id = t.id AND i.card_type_id = 2
LEFT JOIN energies e ON i.card_id = e.id AND i.card_type_id = 3
WHERE user_id = ?
`

type CollectionFindByUserIdRow struct {
	ID         int64  `json:"id"`
	CardID     int64  `json:"card_id"`
	CardTypeID int64  `json:"card_type_id"`
	Name       string `json:"name"`
	ImageUrl   string `json:"image_url"`
	Quantity   int32  `json:"quantity"`
}

func (q *Queries) CollectionFindByUserId(ctx context.Context, userID string) ([]CollectionFindByUserIdRow, error) {
	rows, err := q.db.QueryContext(ctx, collectionFindByUserId, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CollectionFindByUserIdRow{}
	for rows.Next() {
		var i CollectionFindByUserIdRow
		if err := rows.Scan(
			&i.ID,
			&i.CardID,
			&i.CardTypeID,
			&i.Name,
			&i.ImageUrl,
			&i.Quantity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
